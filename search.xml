<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>贝塞尔曲线的学习一：基本n阶贝塞尔曲线和求导</title>
      <link href="/2021/06/02/suan-fa/bei-sai-er-qu-xian-de-xue-xi-yi-ji-ben-n-jie-bei-sai-er-qu-xian-he-qiu-dao/"/>
      <url>/2021/06/02/suan-fa/bei-sai-er-qu-xian-de-xue-xi-yi-ji-ben-n-jie-bei-sai-er-qu-xian-he-qiu-dao/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>本文主要是从贝塞尔曲线的定义和求导下手进行简单贝塞尔曲线的学习和整理。</code></pre><h2 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1.基本定义"></a>1.基本定义</h2><pre><code>贝塞尔曲线是参数化曲线（Parametric Curves）的一种，其n阶次曲线具有如下的形式：</code></pre><p>$$C(t) = \sum_{i=0}^{n}B_{i,n}(t)p_i$$<br>$$t\in[0,1]$$</p><pre><code>所以写成矩阵的形式有：</code></pre><p>$$C(t) =[B_{0,n}(t),B_{1,n}(t),…,B_{n,n}(t)][P_0^T,P_1^T,…,P_n^T]^T$$</p><pre><code>其中出现了一个名为贝塞尔曲线参数的符号：$$B_&#123;i,n&#125;(t))$$我们将他定义为</code></pre><p>$$B_{i,n}(t)=\frac{n!}{i!(n-i)!}(1-t)^{n-i}t^i$$</p><pre><code>其中其实大部分的内容，我们只需要使用一个n的向量计算出就好。</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*vector&lt;int> factorial*/</span>Point <span class="token function">at</span><span class="token punctuation">(</span><span class="token keyword">double</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>    Point ans<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ans <span class="token operator">+</span><span class="token operator">=</span> factorial<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">/</span>factorial<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>factorial<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="2-求导"><a href="#2-求导" class="headerlink" title="2. 求导"></a>2. 求导</h2><pre><code>因为大部分的时候，我们只需要使用一阶导数和二阶导数，这里只去简单去推导其中两个内容。也是为我们去工业使用时候，比较减少计算量的一个方法。</code></pre><h4 id="2-1-一阶导数"><a href="#2-1-一阶导数" class="headerlink" title="2.1 一阶导数"></a>2.1 一阶导数</h4><pre><code>根据1中内容，我们已知其中对t求导时，应该考虑的主要在贝塞尔曲线参数的t求导。所以我们可以得到下面的求导过程：</code></pre><p>$$\frac{\partial{B_{i,n}(t)}}{\partial{t}}=\frac{n!}{i!(n-i)!}(i(1-t)^{n-i}t^{i-1}-(n-i)(1-t)^{n-i-1}t^i)$$</p><pre><code>由于在头部和尾部就仅仅需要其中一个部分，我们可以有以下的实现：</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*vector&lt;int> factorial*/</span>Point <span class="token function">dev</span><span class="token punctuation">(</span><span class="token keyword">double</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>    Point ans<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ans <span class="token operator">+</span><span class="token operator">=</span> factorial<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">/</span>factorial<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>factorial<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>            i<span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">-</span>            <span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token function">mypow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-2-二阶导数"><a href="#2-2-二阶导数" class="headerlink" title="2.2 二阶导数"></a>2.2 二阶导数</h4><pre><code>二阶导数是基于一阶导数的二次实现，基本上的求导过程和上述内容差不多，也是对贝塞尔曲线参数的求导：</code></pre><p>$$\frac{\partial ^2{B_{i,n}(t)}}{\partial{t^2}}=\frac{\partial \frac{n!}{i!(n-i)!}(i(1-t)^{n-i}t^{i-1}-(n-i)(1-t)^{n-i-1}t^i)}{\partial t} $$</p><p>$$\frac{\partial ^2{B_{i,n}(t)}}{\partial{t^2}}=\frac{n!}{i!(n-i)!}(i(i-1)(1-t)^{n-i}t^{i-2}-2i(n-i)(1-t)^{n-i-1}t^{i-1}+(n-i)(n-i-1)(1-t)^{n-i-2}t^i)$$</p><pre><code>基于上述的公式，我们再次更新我们的代码为：</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*vector&lt;int> factorial*/</span>Point <span class="token function">dev2</span><span class="token punctuation">(</span><span class="token keyword">double</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>    Point ans<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ans <span class="token operator">+</span><span class="token operator">=</span> factorial<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">/</span>factorial<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>factorial<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>              i<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>i<span class="token number">-2</span><span class="token punctuation">)</span>             <span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token function">mypow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span>             <span class="token operator">+</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token function">mypow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token number">-2</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">mypow</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>上述内容主要是介绍了如何去简单的运算贝塞尔曲线，以及它的一阶导数和二阶导数。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝塞尔曲线的学习二：贝塞尔曲线的长度和等长贝塞尔曲线选点</title>
      <link href="/2021/06/02/suan-fa/bei-sai-er-qu-xian-de-xue-xi-er-bei-sai-er-qu-xian-de-chang-du-he-deng-chang-bei-sai-er-qu-xian-xuan-dian/"/>
      <url>/2021/06/02/suan-fa/bei-sai-er-qu-xian-de-xue-xi-er-bei-sai-er-qu-xian-de-chang-du-he-deng-chang-bei-sai-er-qu-xian-xuan-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  在上一个文章中，我们简单地描述了如何使用简单的贝塞尔曲线，以及贝塞尔曲线的求导内容。在本文中将主要介绍贝塞尔曲线长度的求解和等长参数化贝塞尔曲线的计算。</p><h2 id="1-求弧长"><a href="#1-求弧长" class="headerlink" title="1. 求弧长"></a>1. 求弧长</h2><p>  对于如何求解弧长，我们可以使用近似法不断地去逼近弧长的长度。</p><p>$$L=\sum_{j=1}^{m-1}|C(t_{j+1})-C_(t_j)|   \tag{1}$$</p><p>​    根据柯西中值定理，我们可以求解到原式子可以为：</p><p>$$L\approx \sum_{j=1}^{m-1}|C’(t_j^*)|(t_{j+1}-t_j) \tag{2}$$</p><p>​    我们可以使用积分的方式进行求解：</p><p>​    $$L=\int_0^1|C’(t)|dt \tag{3}$$</p><p>​    至于如何求解这个内容，这个对贝塞尔曲线来说是没有解析解的，尤其是对于高维度的贝塞尔点，为了简要的实现这个内容可以使用辛普森3/8规则进行逼近。</p><h4 id="辛普森3-8规则："><a href="#辛普森3-8规则：" class="headerlink" title="辛普森3/8规则："></a>辛普森3/8规则：</h4><p>​    $$\int_a^b f(x)dx = \frac{(b-a)}{8} [f(a)+3f(\frac{2a+b}{3})+3f(\frac{a+2b}{3})+f(b)] \tag{4}$$</p><p>​    一个简单C++实现为：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> NumericalIntegration<span class="token punctuation">{</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token operator">></span><span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">simpson_3_8</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> derivative_func<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> L<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> mid_L <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>L <span class="token operator">+</span> R<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3.0</span><span class="token punctuation">,</span> mid_R <span class="token operator">=</span> <span class="token punctuation">(</span>L <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>R<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3.0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">derivative_func</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">+</span>             <span class="token number">3.0</span> <span class="token operator">*</span> <span class="token function">derivative_func</span><span class="token punctuation">(</span>mid_L<span class="token punctuation">)</span> <span class="token operator">+</span>             <span class="token number">3.0</span> <span class="token operator">*</span> <span class="token function">derivative_func</span><span class="token punctuation">(</span>mid_R<span class="token punctuation">)</span> <span class="token operator">+</span>             <span class="token function">derivative_func</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>R <span class="token operator">-</span> L<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8.0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> F<span class="token operator">></span><span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">adaptive_simpson_3_8</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> derivative_func<span class="token punctuation">,</span>     <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> L<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> R<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> eps <span class="token operator">=</span> <span class="token number">0.0001</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">double</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>L <span class="token operator">+</span> R<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> ST <span class="token operator">=</span> <span class="token function">simpson_3_8</span><span class="token punctuation">(</span>derivative_func<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">,</span>           SL <span class="token operator">=</span> <span class="token function">simpson_3_8</span><span class="token punctuation">(</span>derivative_func<span class="token punctuation">,</span> L<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span>           SR <span class="token operator">=</span> <span class="token function">simpson_3_8</span><span class="token punctuation">(</span>derivative_func<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> ans <span class="token operator">=</span> SL <span class="token operator">+</span> SR <span class="token operator">-</span> ST<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">15.0</span> <span class="token operator">*</span> eps<span class="token punctuation">)</span>  <span class="token keyword">return</span> SL <span class="token operator">+</span> SR <span class="token operator">+</span> ans <span class="token operator">/</span> <span class="token number">15.0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">adaptive_simpson_3_8</span><span class="token punctuation">(</span>derivative_func<span class="token punctuation">,</span> L<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> eps <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">+</span>           <span class="token function">adaptive_simpson_3_8</span><span class="token punctuation">(</span>derivative_func<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> R<span class="token punctuation">,</span> eps <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>​    所以在计算贝塞尔曲线长度的时候，就可以使用下面的公式进行计算：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">computeLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> df <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">double</span> t<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">double</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">dev</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    length_ <span class="token operator">=</span> NumericalIntegration<span class="token operator">::</span><span class="token function">adaptive_simpson_3_8</span><span class="token punctuation">(</span>df<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="2-重参数化（等弧长）"><a href="#2-重参数化（等弧长）" class="headerlink" title="2.重参数化（等弧长）"></a>2.重参数化（等弧长）</h2><p>​    <img src="https://pic4.zhimg.com/80/v2-5de2fabe3f58d8bf91f82b45db51a38f_720w.jpg"></p><p>​    如果我们按照t为，1/k,2/k….，这样的方式进行取点，我们会很容易得到左边的效果。但是我们普遍需要的是右边的等距离点的时候。应该怎么去做呢？</p><p>​    这个时候可以使用重参数化来去进行计算。</p><p>​    我们可以认为存在一个映射，使得：</p><p>$$[0,1]\rightarrow[0,L]$$</p><p>​    而且能够一一映射。这里我们可以定义一个函数为g。</p><p>$$g(t)=\int_0^t|C’(z)|dz \tag{5}$$</p><p>​    该函数严格递增，而且连续可导。那么g函数的反函数h，便能够很简单将长度映射为t。</p><p>​    当然能够取到反函数最好。然后在一些高阶的贝塞尔曲线下，这个是做不到的。</p><p>​    所以就有了参数化逼近的方法：</p><p>​    在1中我们得知了<a href="#%E8%BE%9B%E6%99%AE%E6%A3%AE3/8%E8%A7%84%E5%88%99%EF%BC%9A">辛普森规则</a>，所以我们参数逼近的方法去做。我们可以将问题转化为找t，使得g(t)=s。整体的规划内容就变成了一个约束性问题：</p><p>$$t_s=\underset{t\in[0,1]}{argmin}(g(t)-s)^2 \tag{6}$$</p><p>​    为了使用这个部分，我们会采用牛顿法进行求导：</p><p>$$\begin{align}g’(t)&amp;=2d|C’(t)| \tag{7}\ g’’(t)&amp;=2d|C’’(t)| + |C’(t)|^2 \tag{8}\ d &amp;= g(t)-s \tag{9} \end{align} $$</p><p>​    为了去更新t，我们可以使用下面的迭代公式：</p><p>$$t_{s,n+1}=t_{x,n}-\frac{g’(t)}{g”(t)} \tag{10}$$</p><p>​    在迭代的过程中，我们初始化t为m/k，这个值在一般情况下，很容易去近似真实的结果。但是在这个的情况下，需要多次大量的调用<a href="#%E8%BE%9B%E6%99%AE%E6%A3%AE3/8%E8%A7%84%E5%88%99%EF%BC%9A">辛普森规则</a>，其中的时间开销太大。为了更加有效地去利用，我们这里使用点的距离作为一个近似解。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> iter<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>iter<span class="token operator">&lt;</span>max_iter_time<span class="token punctuation">;</span><span class="token operator">++</span>iter<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span>dists<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ret<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>ret<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> offset <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">double</span> err_dist <span class="token operator">=</span> dists<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> avg_distance<span class="token punctuation">;</span>        offset <span class="token operator">+</span><span class="token operator">=</span> err_dist<span class="token punctuation">;</span>        <span class="token keyword">double</span> first_deriv <span class="token operator">=</span> <span class="token function">dev</span><span class="token punctuation">(</span>t_array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> second_deriv <span class="token operator">=</span> <span class="token function">dev2</span><span class="token punctuation">(</span>t_array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> numerator <span class="token operator">=</span> offset <span class="token operator">*</span> first_deriv<span class="token punctuation">;</span>        <span class="token keyword">double</span> d <span class="token operator">=</span> offset <span class="token operator">*</span> second_deriv <span class="token operator">+</span> first_deriv <span class="token operator">*</span> first_deriv<span class="token punctuation">;</span>        t_array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> numerator<span class="token operator">/</span>d<span class="token punctuation">;</span>        ret<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">at</span><span class="token punctuation">(</span>t_array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>offset<span class="token operator">&lt;</span>eps<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    上面的两个内容主要是本文的讲解重心。本文高度使用了大量的来自知乎中一文的解读。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/130247362">贝塞尔曲线的求导、弧长参数化与分段拟合方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to compile your apache 2.4.47</title>
      <link href="/2021/05/27/pei-zhi-guo-cheng/hello-world/"/>
      <url>/2021/05/27/pei-zhi-guo-cheng/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>在编译apache2.4.47的时候，个人有了很多的问题。所以这里是简明的一个便于去安装的内容，同时也是解决了一些常见的个人问题。<br>TODO:</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apache </tag>
            
            <tag> httpd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World to Hexo</title>
      <link href="/2020/09/11/hello-world/"/>
      <url>/2020/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>我的blog很大程度上不算blog，算是个整合贴。我的blog的流程一般是这样的：</p><p>遇到一个实际问题，或者从完全不了解到初步入门，我会保留自己在解决这个问题的浏览器历史搜索记录（请务必科学上网）、大致流程、特殊问题和解决方案。</p><p>一般不再书写别人已经写作的内容，仅仅贴上链接。虽然不排除链接实效的情况，但是一般来说链接是稳定的。万一实在链接失效，也可以搜索关键词找寻更新的教程。在此不再赘述。</p><h2 id="使用Github-Pages和Hexo构建个人博客"><a href="#使用Github-Pages和Hexo构建个人博客" class="headerlink" title="使用Github Pages和Hexo构建个人博客"></a><a href="https://developer.aliyun.com/article/387750">使用Github Pages和Hexo构建个人博客</a></h2><p>此项目是基于gitpage的托管，在本地nodejs平台渲染hexo项目生成的静态网站。</p><p>静态博客文档的书写一方面是记录了博主的工作，另一方面在线分享也节省了有同样问题或者想要了解、从事某方面研究的人的调研时间，一举两得。</p><p>感谢所有愿意分享的博主，你们的无私让整个社区更加美好。</p><h3 id="Valine无后端评论系统"><a href="#Valine无后端评论系统" class="headerlink" title="Valine无后端评论系统"></a><a href="https://valine.js.org/">Valine无后端评论系统</a></h3><p>这是静态网站中不那么静态的部分——评论系统。</p><p>后台存储使用的是LeanCloud。详细配置文档中有细致说明。</p><h2 id="使用jekyll构建gitpage静态网页"><a href="#使用jekyll构建gitpage静态网页" class="headerlink" title="使用jekyll构建gitpage静态网页"></a><a href="https://sspai.com/post/54608">使用jekyll构建gitpage静态网页</a></h2><p>这是另一种实现静态网站的方案，但是jekyll是基于ruby的，对于windows用户可能不是那么友好，所以推荐使用前面的方案。</p><h2 id="Ubuntu安装Node环境"><a href="#Ubuntu安装Node环境" class="headerlink" title="Ubuntu安装Node环境"></a><a href="https://mupceet.com/2020/02/the-best-way-to-install-nodejs/">Ubuntu安装Node环境</a></h2><p>windows下直接安装就OK。这里采用了NVM的Node版本管理来做安装,并使用国内镜像。</p><h3 id="NVM-github"><a href="#NVM-github" class="headerlink" title="NVM github"></a><a href="https://github.com/nvm-sh/nvm#installing-and-updating">NVM github</a></h3><h2 id="仓库主题下载使用"><a href="#仓库主题下载使用" class="headerlink" title="仓库主题下载使用"></a>仓库主题下载使用</h2><p><a href="https://github.com/zkm98/blinkTheme">仓库地址</a>,请参照 readme运行，参照 themes\hexo-theme-matery\README_CN.md 中说明配置详细主题信息.</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Gitpage </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
